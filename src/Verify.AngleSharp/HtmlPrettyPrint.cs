namespace VerifyTests.AngleSharp;

public static class HtmlPrettyPrint
{
    const StringComparison comparer = StringComparison.OrdinalIgnoreCase;

    public static void All(Action<INodeList>? action = null)
    {
        VerifierSettings.AddScrubber("html", builder => CleanSource(builder, action));
        VerifierSettings.AddScrubber("htm", builder => CleanSource(builder, action));
    }

    public static void ScrubEmptyDivs(this INodeList nodes) =>
        ScrubEmptyDivs(nodes.OfType<IElement>());

    public static void ScrubEmptyDivs(this IEnumerable<IElement> elements)
    {
        foreach (var element in elements.DescendantsAndSelf<IElement>())
        {
            TryScrubDiv(element);
        }
    }

    public static bool TryScrubDiv(this IElement element)
    {
        if (element is not IHtmlDivElement div)
        {
            return false;
        }

        div.InnerHtml = div.InnerHtml.TrimEnd();
        if (element.HasAttributes())
        {
            return false;
        }

        if (!element.HasChildNodes)
        {
            element.RemoveFromParent();
        }
        else if (element.Children.Length == 1)
        {
            var child = element.FirstChild;
            element.Parent!.AppendChild(child);
        }

        return true;
    }

    public static void ScrubAttributes(this INodeList nodes, string name) =>
        ScrubAttributes(nodes.OfType<IElement>(), name);

    public static void ScrubAttributes(this INodeList nodes, Func<IAttr, bool> match) =>
        ScrubAttributes(nodes.OfType<IElement>(), match);

    public static void ScrubAttributes(this INodeList nodes, Func<IAttr, string?> match) =>
        ScrubAttributes(nodes.OfType<IElement>(), match);

    public static void ScrubAttributes(this IEnumerable<IElement> elements, string name) =>
        elements.ScrubAttributes(_ => _.Name == name);

    public static void ScrubAttributes(this IEnumerable<IElement> elements, Func<IAttr, string?> tryGetValue)
    {
        foreach (var element in elements.DescendantsAndSelf<IElement>())
        {
            foreach (var attribute in element.Attributes)
            {
                var value = tryGetValue(attribute);
                if (value != null)
                {
                    attribute.Value = value;
                }
            }
        }
    }

    public static void ScrubAttributes(this IEnumerable<IElement> elements, Func<IAttr, bool> match)
    {
        foreach (var element in elements.DescendantsAndSelf<IElement>())
        {
            foreach (var attribute in element.Attributes.ToList())
            {
                if (match(attribute))
                {
                    element.RemoveAttribute(attribute.Name);
                }
            }
        }
    }

    public static void PrettyPrintHtml(
        this VerifySettings settings,
        Action<INodeList>? action = null)
    {
        settings.AddScrubber("html", builder => CleanSource(builder, action));
        settings.AddScrubber("htm", builder => CleanSource(builder, action));
    }

    public static SettingsTask PrettyPrintHtml(
        this SettingsTask settings,
        Action<INodeList>? action = null)
    {
        settings.AddScrubber("html", builder => CleanSource(builder, action));
        settings.AddScrubber("htm", builder => CleanSource(builder, action));
        return settings;
    }

    /// <summary>
    /// Replaces the automatic cache-busting tag generated by the asp-append-version
    /// tag helper with constant string "{TAG_HELPER_VERSION}".
    /// </summary>
    /// <param name="nodes">
    /// The <see cref="INodeList"/> containing the DOM elements.
    /// </param>
    public static void ScrubAspCacheBusterTagHelper(this INodeList nodes) =>
        nodes.OfType<IElement>().ScrubAspCacheBusterTagHelper();

    /// <summary>
    /// Replaces the automatic cache-busting tag generated by the asp-append-version
    /// tag helper with constant string "{TAG_HELPER_VERSION}".
    /// </summary>
    /// <param name="elements">
    /// The collection of  <see cref="IElement"/> containing the DOM elements.
    /// </param>
    public static void ScrubAspCacheBusterTagHelper(this IEnumerable<IElement> elements) =>
        elements.ScrubAttributes(static attr =>
        {
            if (attr.Name.Equals("href", comparer) || attr.Name.Equals("src", comparer))
            {
                const string pattern = @"([^""?]+[?&]v=)[\w\-]+";
                const string replacement = "$1{TAG_HELPER_VERSION}";

                return Regex.Replace(attr.Value, pattern, replacement);
            }

            return attr.Value;
        });

    /// <summary>
    /// Removes elements injected by Browser Link.
    /// </summary>
    /// <param name="nodes">
    /// The <see cref="INodeList"/> containing the DOM elements.
    /// </param>
    public static void ScrubBrowserLink(this INodeList nodes)
    {
        List<INode> nodesToRemove = [];

        foreach (var comment in nodes.DescendantsAndSelf<IComment>())
        {
            var content = comment.TextContent;
            if (content.Contains("Visual Studio Browser Link", comparer)
                || content.Contains("End Browser Link", comparer))
            {
                nodesToRemove.Add(comment);
                nodesToRemove.AddRange(CollectAdjacentWhitespace(comment));
            }
        }

        foreach (var element in nodes.DescendantsAndSelf<IElement>())
        {
            if (element.TagName.Equals("script", comparer))
            {
                var src = element.GetAttribute("src") ?? string.Empty;
                if (src.Equals("/_vs/browserLink", comparer) || src.Equals("/_framework/aspnetcore-browser-refresh.js", comparer))
                {
                    nodesToRemove.Add(element);
                    nodesToRemove.AddRange(CollectAdjacentWhitespace(element));
                }
            }
        }

        foreach (var node in nodesToRemove)
        {
            node.Parent?.RemoveChild(node);
        }
    }

    static IEnumerable<INode> CollectAdjacentWhitespace(INode node)
    {
        return Collect(node, n => n.PreviousSibling)
            .Union(Collect(node, n => n.NextSibling));

        static IEnumerable<INode> Collect(INode n, Func<INode, INode?> iterator)
        {
            var current = iterator(n);
            while (current is not null)
            {
                if (current is IText text && IsWhitespaceOnly(text.TextContent))
                {
                    yield return current;
                    current = iterator(current);
                }
                else
                {
                    break;
                }
            }
        }
    }

    static bool IsWhitespaceOnly(string text) => string.IsNullOrEmpty(text) || text.All(char.IsWhiteSpace);

    static void CleanSource(StringBuilder builder, Action<INodeList>? action)
    {
        var source = builder.ToString();
        var document = Parse(source);
        action?.Invoke(document);

        builder.Clear();
        var formatter = new PrettyMarkupFormatter
        {
            Indentation = "  ",
            NewLine = "\n"
        };
        using var writer = new StringWriter(builder);
        document.ToHtml(writer, formatter);
        writer.Flush();
    }

    static INodeList Parse(string source)
    {
        var parser = new HtmlParser();
        if (source.StartsWith("<!DOCTYPE html>", StringComparison.InvariantCultureIgnoreCase) ||
            source.StartsWith("<html>", StringComparison.InvariantCultureIgnoreCase))
        {
            return parser.ParseDocument(source).ChildNodes;
        }

        var dom = parser.ParseDocument("<html><body></body></html>");
        return parser.ParseFragment(source, dom.Body!);
    }
}
